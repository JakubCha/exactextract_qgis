# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ZonalExactDialog
                                 A QGIS plugin
 Zonal Statistics of rasters using Exact Extract library
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-02-11
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jakub Charyton
        email                : jakub.charyton@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time
from typing import List

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsMapLayerProxyModel, QgsTask, QgsApplication, QgsTaskManager, QgsMessageLog

import geopandas as gpd
import pandas as pd
from exactextract import exact_extract

from .dialog_input_dto import DialogInputDTO
from .user_communication import UserCommunication

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'zonal_exact_dialog_base.ui'))


class ZonalExactDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, uc: UserCommunication = None, iface = None, task_manager: QgsTaskManager = None):
        """Constructor."""
        super(ZonalExactDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.dialog_input: DialogInputDTO = None
        self.tasks = []
        self.intermediate_result_list = []
        self.postprocess_task: PostprocessStatsTask = None
        self.input_gdf: gpd.GeoDataFrame = None
        
        self.uc = uc
        self.iface = iface
        self.task_manager: QgsTaskManager = task_manager
        
        self.calculated_stats_list = []
        
        self.setupUi(self)
        
        self.mRasterLayerComboBox.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.mVectorLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
        
        self.mCalculateButton.clicked.connect(self.calculate)

    def calculate(self):
        self.get_input_values()
        if self.dialog_input is None:
            return
        # open vector layer and calculate batch size to split vectors
        self.input_gdf = gpd.read_file(self.dialog_input.vector_layer_path, layer=self.dialog_input.input_layername, engine='pyogrio')
        self.input_gdf = self.input_gdf.reset_index().rename(columns={"index":"id"}).astype({'id':'int32'})
        batch_size = round(len(self.input_gdf) / self.dialog_input.parallel_jobs)
        # calculate using QgsTask and exactextract
        self.process_calculations(self.input_gdf, batch_size)
        # wait for calculations to finish to continue
        if self.postprocess_task is not None:
            self.postprocess_task.taskCompleted.connect(self.save_result)
        
        pass
    
    def process_calculations(self, vector_gdf, batch_size):
        self.intermediate_result_list = []
        # parent_task = ParentTask(f'parent task 1', QgsTask.CanCancel, result_list=self.intermediate_result_list)
        self.postprocess_task = PostprocessStatsTask(f'Zonal ExactExtract task', QgsTask.CanCancel, result_list=self.intermediate_result_list,
                                                stats=self.dialog_input.aggregates_stats_list+self.dialog_input.arrays_stats_list,
                                                index_column='id', index_column_dtype=self.input_gdf['id'].dtype, prefix='test_prefix_')
        self.tasks = []
        for i in range(0, self.input_gdf.shape[0], batch_size):
            temp_vector_gdf = vector_gdf[i:i + batch_size]

            calculation_subtask = CalculateStatsTask(f'calculation subtask {i}', flags=QgsTask.Silent, result_list=self.intermediate_result_list,
                                                     polygon_layer_gdf=temp_vector_gdf, raster=self.dialog_input.raster_layer_path,
                                                     stats=self.dialog_input.aggregates_stats_list+self.dialog_input.arrays_stats_list,
                                                     include_cols=['id'])
            self.tasks.append(calculation_subtask)
            self.postprocess_task.addSubTask(calculation_subtask, [], QgsTask.ParentDependsOnSubTask)

        # self.task_manager.addTask(parent_task)
        self.task_manager.addTask(self.postprocess_task)
            
            
    def save_result(self):
        calculated_stats_df = self.postprocess_task.calculated_stats
        QgsMessageLog.logMessage(f'Zonal ExactExtract task result shape: {str(calculated_stats_df.shape)}')
        
        polygon_layer_stats_gdf = pd.merge(self.input_gdf, calculated_stats_df, on='id', how='left')
        polygon_layer_stats_gdf.to_file(self.dialog_input.output_file_path, engine='pyogrio')
    
    
    def get_input_values(self):
        raster_layer_path, vector_layer_path = self.get_files_paths()
        parallel_jobs = self.mSpinBox.value()
        output_file_path = self.mQgsOutputFileWidget.filePath()
        aggregates_stats_list = self.mAggregatesComboBox.checkedItems()
        arrays_stats_list = self.mArraysComboBox.checkedItems()
        
        if not raster_layer_path or not vector_layer_path:
            self.uc.bar_warn(f"You didn't select raster layer or vector layer")
            return
        if not output_file_path:
            self.uc.bar_warn(f"You didn't select output file path")
            return
        # check if both stats lists are empty
        if not aggregates_stats_list and not arrays_stats_list:
            self.uc.bar_warn(f"You didn't select anything from either Aggregates and Arrays")
            return
        
        self.dialog_input = DialogInputDTO(raster_layer_path, vector_layer_path, parallel_jobs, output_file_path,
                                           aggregates_stats_list, arrays_stats_list)
    
    def get_files_paths(self):
        raster_layer_path = self.mRasterLayerComboBox.currentLayer().dataProvider().dataSourceUri()
        vector_layer_path = self.mVectorLayerComboBox.currentLayer().dataProvider().dataSourceUri()

        return raster_layer_path, vector_layer_path        


class CalculateStatsTask(QgsTask):
    def __init__(self, description, flags, result_list, polygon_layer_gdf, raster, stats, include_cols):
        super().__init__(description, flags)
        self.description = description
        self.polygon_layer_gdf = polygon_layer_gdf
        self.raster = raster
        self.stats = stats
        self.include_cols = include_cols
        
        self.result_list = result_list
    
    def run(self):
        QgsMessageLog.logMessage(f'Started task: {self.description}')
        print(f'Started task: {self.description}')
        
        result_stats = exact_extract(vec=self.polygon_layer_gdf, rast=self.raster, ops=self.stats, include_cols=self.include_cols, output="pandas")
        self.result_list.append(result_stats)
        
        return True
        
    def finished(self, result):
        pass

class PostprocessStatsTask(QgsTask):
    def __init__(self, description, flags, result_list, index_column, index_column_dtype, stats, prefix):
        super().__init__(description, flags)
        self.description = description
        self.result_list = result_list
        self.index_column = index_column
        self.index_column_dtype = index_column_dtype
        self.stats = stats
        self.prefix = prefix
        
        self.calculated_stats = None
        
    def run(self):
        QgsMessageLog.logMessage(f'Inside Postprocess Task: {self.description}')
        
        # result_indexed_list = [df.set_index(self.index_column) for df in self.result_list]
        calculated_stats = pd.concat(self.result_list)
        
        if self.index_column is not None and self.index_column_dtype is not None:
            # change index dtype to dtype of index column in input layer
            index_dtype = str(self.index_column_dtype)
            calculated_stats = calculated_stats.astype({self.index_column:index_dtype})
        
        if len(self.prefix) > 0:
            # rename columns to include prefix string
            rename_dict = {stat: f"{self.prefix}_{stat}" for stat in self.stats}
            calculated_stats = calculated_stats.rename(columns=rename_dict)
        
        self.calculated_stats = calculated_stats
        
        return True
    
    def finished(self, result):
        pass